"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unwrap = exports.isProxy = exports["default"] = void 0;

var _shared = require("@rpldy/shared");

var mergeWithSymbols = (0, _shared.getMerge)({
  withSymbols: true
});
var PROXY_SYM = Symbol["for"]("__rpldy-sstt-proxy__"),
    STATE_SYM = Symbol["for"]("__rpldy-sstt-state__");
var isProd = process.env.NODE_ENV === "production";

var isProxy = function isProxy(obj) {
  return !isProd && !!~Object.getOwnPropertySymbols(obj).indexOf(PROXY_SYM);
};

exports.isProxy = isProxy;

var getIsUpdateable = function getIsUpdateable(proxy) {
  return isProd ? true : proxy[STATE_SYM].isUpdateable;
};

var setIsUpdateable = function setIsUpdateable(proxy, value) {
  if (!isProd) {
    proxy[STATE_SYM].isUpdateable = value;
  }
};

var deepProxy = function deepProxy(obj, traps) {
  var proxy;

  if (Array.isArray(obj) || (0, _shared.isPlainObject)(obj)) {
    if (!isProxy(obj)) {
      obj[PROXY_SYM] = true;
      proxy = new Proxy(obj, traps);
    }

    Object.keys(obj).forEach(function (key) {
      obj[key] = deepProxy(obj[key], traps);
    });
  }

  return proxy || obj;
};

var deepUnWrap = function deepUnWrap(proxy) {
  delete proxy[PROXY_SYM];
  Object.keys(proxy).concat(Object.getOwnPropertySymbols(proxy).filter(function (sym) {
    return sym !== STATE_SYM;
  })).forEach(function (key) {
    proxy[key] = proxy[key] && (proxy[key][PROXY_SYM] || proxy[key]);
  });
  return proxy;
};

var unwrapEntry = function unwrapEntry(proxy) {
  return isProxy(proxy) ? (0, _shared.clone)(proxy, mergeWithSymbols) : proxy;
};

exports.unwrap = unwrapEntry;

var unwrapState = function unwrapState(proxy) {
  delete proxy[STATE_SYM];
  return proxy[PROXY_SYM];
};
/**
 * deep proxies an object so it is only updateable through an update callback.
 * outside an updater, it is impossible to make changes
 *
 * This a very (very) basic and naive replacement for Immer
 *
 * It only proxies simple objects (not maps or sets) and arrays
 * It doesnt create new references and doesnt copy over anything
 *
 * Original object is changed!
 *
 * DOESNT support updating state (wrapped seperately) that is set as a child of another state
 * @param obj
 * @returns {{state, update, unwrap}}
 */


var _default = function _default(obj) {
  var traps = {
    set: function set(obj, key, value) {
      if (getIsUpdateable(proxy)) {
        obj[key] = deepProxy(value, traps);
      }

      return true;
    },
    get: function get(obj, key) {
      return key === PROXY_SYM ? deepUnWrap(obj) : obj[key];
    },
    defineProperty: function defineProperty() {
      throw new Error("Simple State doesnt support defining property");
    },
    setPrototypeOf: function setPrototypeOf() {
      throw new Error("Simple State doesnt support setting prototype");
    },
    deleteProperty: function deleteProperty(obj, key) {
      if (getIsUpdateable(proxy)) {
        delete obj[key];
      }

      return true;
    }
  };

  if (!isProd && !isProxy(obj)) {
    Object.defineProperty(obj, STATE_SYM, {
      value: {
        isUpdateable: false
      },
      configurable: true
    });
  }

  var proxy = !isProd ? deepProxy(obj, traps) : obj;

  var update = function update(fn) {
    if (!isProd && getIsUpdateable(proxy)) {
      throw new Error("Can't call update on State already being updated!");
    }

    try {
      setIsUpdateable(proxy, true);
      fn(proxy);
    } finally {
      setIsUpdateable(proxy, false);
    }

    return proxy;
  };

  var unwrap = function unwrap(entry) {
    return entry ? //simply clone the provided object (if its a proxy)
    unwrapEntry(entry) : //unwrap entire proxy state
    isProxy(proxy) ? unwrapState(proxy) : proxy;
  };

  return {
    state: proxy,
    update: update,
    unwrap: unwrap
  };
};

exports["default"] = _default;