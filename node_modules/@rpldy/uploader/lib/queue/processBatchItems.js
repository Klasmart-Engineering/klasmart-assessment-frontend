"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;

var _shared = require("@rpldy/shared");

var _simpleState = require("@rpldy/simple-state");

var _consts = require("../consts");

var _processFinishedRequest = _interopRequireDefault(require("./processFinishedRequest"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var mergeWithUndefined = (0, _shared.getMerge)({
  undefinedOverwrites: true
});

var triggerPreSendUpdate = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(queue, items, options) {
    var updated;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _context.next = 2;
            return (0, _shared.triggerUpdater)(queue.trigger, _consts.UPLOADER_EVENTS.REQUEST_PRE_SEND, {
              items: items.map(function (i) {
                return (0, _simpleState.unwrap)(i);
              }),
              options: (0, _simpleState.unwrap)(options)
            });

          case 2:
            updated = _context.sent;

            if (!updated) {
              _context.next = 10;
              break;
            }

            _shared.logger.debugLog("uploader.queue: REQUEST_PRE_SEND event returned updated items/options", updated);

            if (!updated.items) {
              _context.next = 9;
              break;
            }

            if (!(updated.items.length !== items.length || !(0, _shared.isSamePropInArrays)(updated.items, items, ["id", "batchId", "recycled"]))) {
              _context.next = 8;
              break;
            }

            throw new Error("REQUEST_PRE_SEND event handlers must return same items with same ids");

          case 8:
            items = updated.items;

          case 9:
            if (updated.options) {
              options = mergeWithUndefined({}, options, updated.options);
            }

          case 10:
            return _context.abrupt("return", {
              items: items,
              options: options,
              cancelled: updated === false
            });

          case 11:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function triggerPreSendUpdate(_x, _x2, _x3) {
    return _ref.apply(this, arguments);
  };
}();

var prepareAllowedItems = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(queue, items) {
    var allowedIds, prepared, updatedState;
    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            allowedIds = items.map(function (item) {
              return item.id;
            });
            queue.updateState(function (state) {
              state.activeIds = state.activeIds.concat(allowedIds);
            });
            _context2.next = 4;
            return triggerPreSendUpdate(queue, items, queue.getState().batches[items[0].batchId].batchOptions);

          case 4:
            prepared = _context2.sent;

            if (!prepared.cancelled) {
              //update potentially changed data back into queue state
              queue.updateState(function (state) {
                prepared.items.forEach(function (i) {
                  state.items[i.id] = i;
                });
                state.batches[items[0].batchId].batchOptions = prepared.options;
              }); //use objects from internal state(proxies) - not objects from userland

              updatedState = queue.getState();
              prepared.items = prepared.items.map(function (item) {
                return updatedState.items[item.id];
              });
              prepared.options = updatedState.batches[items[0].batchId].batchOptions;
            }

            return _context2.abrupt("return", prepared);

          case 7:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2);
  }));

  return function prepareAllowedItems(_x4, _x5) {
    return _ref2.apply(this, arguments);
  };
}();

var updateUploadingState = function updateUploadingState(queue, items, sendResult) {
  queue.updateState(function (state) {
    items.forEach(function (bi) {
      var item = state.items[bi.id];
      item.state = _shared.FILE_STATES.UPLOADING;
      state.aborts[bi.id] = sendResult.abort;
    });
  });
};

var sendAllowedItems = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(queue, itemsSendData, next) {
    var items, options, batch, sendResult, requestInfo, finishedData;
    return regeneratorRuntime.wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            items = itemsSendData.items, options = itemsSendData.options;
            batch = queue.getState().batches[items[0].batchId].batch;
            sendResult = queue.sender.send(items, batch, options);
            updateUploadingState(queue, items, sendResult);
            _context3.next = 6;
            return sendResult.request;

          case 6:
            requestInfo = _context3.sent;
            //wait for server request to return
            finishedData = items.map(function (item) {
              return {
                id: item.id,
                info: requestInfo
              };
            });
            (0, _processFinishedRequest["default"])(queue, finishedData, next);

          case 9:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3);
  }));

  return function sendAllowedItems(_x6, _x7, _x8) {
    return _ref3.apply(this, arguments);
  };
}();

var reportCancelledItems = function reportCancelledItems(queue, items, cancelledResults, next) {
  var cancelledItemsIds = cancelledResults.map(function (isCancelled, index) {
    return isCancelled ? items[index].id : null;
  }).filter(Boolean);

  if (cancelledItemsIds.length) {
    var finishedData = cancelledItemsIds.map(function (id) {
      return {
        id: id,
        info: {
          status: 0,
          state: _shared.FILE_STATES.CANCELLED,
          response: "cancel"
        }
      };
    });
    (0, _processFinishedRequest["default"])(queue, finishedData, next); //report about cancelled items
  }

  return !!cancelledItemsIds.length;
}; //make sure item is still pending. Something might have changed while waiting for ITEM_START handling. Maybe someone called abort...


var getAllowedItem = function getAllowedItem(id, queue) {
  return queue.getState().items[id];
}; //send group of items to be uploaded


var _default = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(queue, ids, next) {
    var state, items, cancelledResults, allowedItems, itemsSendData;
    return regeneratorRuntime.wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            state = queue.getState(); //ids will have more than one when grouping is allowed

            items = Object.values(state.items);
            items = items.filter(function (item) {
              return !!~ids.indexOf(item.id);
            }); //allow user code cancel items from start event handler(s)

            _context4.next = 5;
            return Promise.all(items.map(function (i) {
              return queue.cancellable(_consts.UPLOADER_EVENTS.ITEM_START, i);
            }));

          case 5:
            cancelledResults = _context4.sent;
            allowedItems = cancelledResults.map(function (isCancelled, index) {
              return isCancelled ? null : getAllowedItem(items[index].id, queue);
            }).filter(Boolean);

            if (!allowedItems.length) {
              _context4.next = 12;
              break;
            }

            _context4.next = 10;
            return prepareAllowedItems(queue, allowedItems);

          case 10:
            itemsSendData = _context4.sent;

            if (itemsSendData.cancelled) {
              cancelledResults = ids.map(function () {
                return true;
              });
            } else {
              //we dont need to wait for the response here
              sendAllowedItems(queue, itemsSendData, next);
            }

          case 12:
            if (reportCancelledItems(queue, items, cancelledResults, next)) {
              _context4.next = 15;
              break;
            }

            _context4.next = 15;
            return next(queue);

          case 15:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4);
  }));

  return function (_x9, _x10, _x11) {
    return _ref4.apply(this, arguments);
  };
}();

exports["default"] = _default;