"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getBatchFromState = exports.getIsItemBatchReady = exports.triggerUploaderBatchEvent = exports.cleanUpFinishedBatch = exports.getBatchDataFromItemId = exports.isItemBelongsToBatch = exports.getBatchFromItemId = exports.cancelBatchForItem = exports.isNewBatchStarting = exports.loadNewBatchForItem = exports.isBatchFinished = void 0;

var _shared = require("@rpldy/shared");

var _simpleState = require("@rpldy/simple-state");

var _consts = require("../consts");

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var BATCH_READY_STATES = [_shared.BATCH_STATES.ADDED, _shared.BATCH_STATES.PROCESSING, _shared.BATCH_STATES.UPLOADING];

var getBatchFromState = function getBatchFromState(state, id) {
  return state.batches[id].batch;
};

exports.getBatchFromState = getBatchFromState;

var getBatch = function getBatch(queue, id) {
  return getBatchFromState(queue.getState(), id);
};

var isItemBelongsToBatch = function isItemBelongsToBatch(queue, itemId, batchId) {
  return queue.getState().items[itemId].batchId === batchId;
};

exports.isItemBelongsToBatch = isItemBelongsToBatch;

var getBatchDataFromItemId = function getBatchDataFromItemId(queue, itemId) {
  var state = queue.getState();
  var item = state.items[itemId];
  return state.batches[item.batchId];
};

exports.getBatchDataFromItemId = getBatchDataFromItemId;

var getBatchFromItemId = function getBatchFromItemId(queue, itemId) {
  return getBatchDataFromItemId(queue, itemId).batch;
};

exports.getBatchFromItemId = getBatchFromItemId;

var removeBatchItems = function removeBatchItems(queue, batchId) {
  var batch = getBatch(queue, batchId),
      batchItemIds = batch.items.map(function (item) {
    return item.id;
  });
  queue.updateState(function (state) {
    batchItemIds.forEach(function (id) {
      delete state.items[id];
      var index = state.itemQueue.indexOf(id);

      if (~index) {
        state.itemQueue.splice(index, 1);
      }
    });
  });
};

var removeBatch = function removeBatch(queue, batchId) {
  queue.updateState(function (state) {
    delete state.batches[batchId];
  });
};

var cancelBatchForItem = function cancelBatchForItem(queue, itemId) {
  var batch = getBatchFromItemId(queue, itemId),
      batchId = batch.id;

  _shared.logger.debugLog("uploady.uploader.processor: cancelling batch: ", {
    batch: batch
  });

  queue.updateState(function (state) {
    var batch = getBatchFromState(state, batchId);
    batch.state = _shared.BATCH_STATES.CANCELLED;
  });
  triggerUploaderBatchEvent(queue, batchId, _consts.UPLOADER_EVENTS.BATCH_CANCEL);
  removeBatchItems(queue, batchId);
  removeBatch(queue, batchId);
};

exports.cancelBatchForItem = cancelBatchForItem;

var isNewBatchStarting = function isNewBatchStarting(queue, itemId) {
  var batch = getBatchFromItemId(queue, itemId);
  return queue.getState().currentBatch !== batch.id;
};

exports.isNewBatchStarting = isNewBatchStarting;

var loadNewBatchForItem = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(queue, itemId) {
    var batch, isCancelled;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            batch = getBatchFromItemId(queue, itemId);
            _context.next = 3;
            return queue.cancellable(_consts.UPLOADER_EVENTS.BATCH_START, batch);

          case 3:
            isCancelled = _context.sent;

            if (!isCancelled) {
              queue.updateState(function (state) {
                state.currentBatch = batch.id;
              });
            }

            return _context.abrupt("return", !isCancelled);

          case 6:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  }));

  return function loadNewBatchForItem(_x, _x2) {
    return _ref.apply(this, arguments);
  };
}();

exports.loadNewBatchForItem = loadNewBatchForItem;

var isBatchFinished = function isBatchFinished(queue) {
  var itemQueue = queue.getState().itemQueue;
  return itemQueue.length === 0 || isNewBatchStarting(queue, itemQueue[0]);
};

exports.isBatchFinished = isBatchFinished;

var cleanUpFinishedBatch = function cleanUpFinishedBatch(queue) {
  var state = queue.getState();
  var batchId = state.currentBatch;

  if (batchId && isBatchFinished(queue)) {
    triggerUploaderBatchEvent(queue, batchId, _consts.UPLOADER_EVENTS.BATCH_FINISH);
    removeBatchItems(queue, batchId);
    removeBatch(queue, batchId);
  }
};

exports.cleanUpFinishedBatch = cleanUpFinishedBatch;

var triggerUploaderBatchEvent = function triggerUploaderBatchEvent(queue, batchId, event) {
  var state = queue.getState(),
      batch = getBatchFromState(state, batchId),
      //get the most uptodate batch data
  stateItems = state.items;

  var eventBatch = _objectSpread(_objectSpread({}, (0, _simpleState.unwrap)(batch)), {}, {
    items: batch.items.map(function (_ref2) {
      var id = _ref2.id;
      return (0, _simpleState.unwrap)(stateItems[id]);
    })
  });

  queue.trigger(event, eventBatch);
};

exports.triggerUploaderBatchEvent = triggerUploaderBatchEvent;

var getIsItemBatchReady = function getIsItemBatchReady(queue, itemId) {
  var batch = getBatchFromItemId(queue, itemId);
  return BATCH_READY_STATES.includes(batch.state);
};

exports.getIsItemBatchReady = getIsItemBatchReady;