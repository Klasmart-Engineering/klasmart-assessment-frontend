{"ast":null,"code":"import { __awaiter, __extends, __generator } from \"tslib\";\nimport { ApolloLink } from \"../core/index.js\";\nimport { Observable } from \"../../utilities/index.js\";\nimport { buildDelayFunction } from \"./delayFunction.js\";\nimport { buildRetryFunction } from \"./retryFunction.js\";\n\nvar RetryableOperation = function () {\n  function RetryableOperation(operation, nextLink, delayFor, retryIf) {\n    var _this = this;\n\n    this.operation = operation;\n    this.nextLink = nextLink;\n    this.delayFor = delayFor;\n    this.retryIf = retryIf;\n    this.retryCount = 0;\n    this.values = [];\n    this.complete = false;\n    this.canceled = false;\n    this.observers = [];\n    this.currentSubscription = null;\n\n    this.onNext = function (value) {\n      _this.values.push(value);\n\n      for (var _i = 0, _a = _this.observers; _i < _a.length; _i++) {\n        var observer = _a[_i];\n        if (!observer) continue;\n        observer.next(value);\n      }\n    };\n\n    this.onComplete = function () {\n      _this.complete = true;\n\n      for (var _i = 0, _a = _this.observers; _i < _a.length; _i++) {\n        var observer = _a[_i];\n        if (!observer) continue;\n        observer.complete();\n      }\n    };\n\n    this.onError = function (error) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var shouldRetry, _i, _a, observer;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              this.retryCount += 1;\n              return [4, this.retryIf(this.retryCount, this.operation, error)];\n\n            case 1:\n              shouldRetry = _b.sent();\n\n              if (shouldRetry) {\n                this.scheduleRetry(this.delayFor(this.retryCount, this.operation, error));\n                return [2];\n              }\n\n              this.error = error;\n\n              for (_i = 0, _a = this.observers; _i < _a.length; _i++) {\n                observer = _a[_i];\n                if (!observer) continue;\n                observer.error(error);\n              }\n\n              return [2];\n          }\n        });\n      });\n    };\n  }\n\n  RetryableOperation.prototype.subscribe = function (observer) {\n    if (this.canceled) {\n      throw new Error(\"Subscribing to a retryable link that was canceled is not supported\");\n    }\n\n    this.observers.push(observer);\n\n    for (var _i = 0, _a = this.values; _i < _a.length; _i++) {\n      var value = _a[_i];\n      observer.next(value);\n    }\n\n    if (this.complete) {\n      observer.complete();\n    } else if (this.error) {\n      observer.error(this.error);\n    }\n  };\n\n  RetryableOperation.prototype.unsubscribe = function (observer) {\n    var index = this.observers.indexOf(observer);\n\n    if (index < 0) {\n      throw new Error(\"RetryLink BUG! Attempting to unsubscribe unknown observer!\");\n    }\n\n    this.observers[index] = null;\n\n    if (this.observers.every(function (o) {\n      return o === null;\n    })) {\n      this.cancel();\n    }\n  };\n\n  RetryableOperation.prototype.start = function () {\n    if (this.currentSubscription) return;\n    this.try();\n  };\n\n  RetryableOperation.prototype.cancel = function () {\n    if (this.currentSubscription) {\n      this.currentSubscription.unsubscribe();\n    }\n\n    clearTimeout(this.timerId);\n    this.timerId = undefined;\n    this.currentSubscription = null;\n    this.canceled = true;\n  };\n\n  RetryableOperation.prototype.try = function () {\n    this.currentSubscription = this.nextLink(this.operation).subscribe({\n      next: this.onNext,\n      error: this.onError,\n      complete: this.onComplete\n    });\n  };\n\n  RetryableOperation.prototype.scheduleRetry = function (delay) {\n    var _this = this;\n\n    if (this.timerId) {\n      throw new Error(\"RetryLink BUG! Encountered overlapping retries\");\n    }\n\n    this.timerId = setTimeout(function () {\n      _this.timerId = undefined;\n\n      _this.try();\n    }, delay);\n  };\n\n  return RetryableOperation;\n}();\n\nvar RetryLink = function (_super) {\n  __extends(RetryLink, _super);\n\n  function RetryLink(options) {\n    var _this = _super.call(this) || this;\n\n    var _a = options || {},\n        attempts = _a.attempts,\n        delay = _a.delay;\n\n    _this.delayFor = typeof delay === 'function' ? delay : buildDelayFunction(delay);\n    _this.retryIf = typeof attempts === 'function' ? attempts : buildRetryFunction(attempts);\n    return _this;\n  }\n\n  RetryLink.prototype.request = function (operation, nextLink) {\n    var retryable = new RetryableOperation(operation, nextLink, this.delayFor, this.retryIf);\n    retryable.start();\n    return new Observable(function (observer) {\n      retryable.subscribe(observer);\n      return function () {\n        retryable.unsubscribe(observer);\n      };\n    });\n  };\n\n  return RetryLink;\n}(ApolloLink);\n\nexport { RetryLink };","map":{"version":3,"mappings":"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","names":["ApolloLink","Observable","buildDelayFunction","buildRetryFunction","operation","nextLink","delayFor","retryIf","value","_this","values","push","observers","_i","observer","next","complete","error","retryCount","shouldRetry","_b","scheduleRetry","_a","RetryableOperation","canceled","Error","index","indexOf","every","cancel","currentSubscription","try","unsubscribe","clearTimeout","timerId","undefined","subscribe","onNext","onError","onComplete","delay","setTimeout","__extends","options","_super","attempts","RetryLink","retryable","start"],"sources":["/Users/evik/kl/project-2024/klasmart-assessment-frontend/node_modules/@apollo/src/link/retry/retryLink.ts"],"sourcesContent":["import { ApolloLink, Operation, FetchResult, NextLink } from '../core';\nimport { Observable, Observer, ObservableSubscription } from '../../utilities';\nimport {\n  DelayFunction,\n  DelayFunctionOptions,\n  buildDelayFunction,\n} from './delayFunction';\nimport {\n  RetryFunction,\n  RetryFunctionOptions,\n  buildRetryFunction,\n} from './retryFunction';\n\nexport namespace RetryLink {\n  export interface Options {\n    /**\n     * Configuration for the delay strategy to use, or a custom delay strategy.\n     */\n    delay?: DelayFunctionOptions | DelayFunction;\n\n    /**\n     * Configuration for the retry strategy to use, or a custom retry strategy.\n     */\n    attempts?: RetryFunctionOptions | RetryFunction;\n  }\n}\n\n/**\n * Tracking and management of operations that may be (or currently are) retried.\n */\nclass RetryableOperation<TValue = any> {\n  private retryCount: number = 0;\n  private values: any[] = [];\n  private error: any;\n  private complete = false;\n  private canceled = false;\n  private observers: (Observer<TValue> | null)[] = [];\n  private currentSubscription: ObservableSubscription | null = null;\n  private timerId: number | undefined;\n\n  constructor(\n    private operation: Operation,\n    private nextLink: NextLink,\n    private delayFor: DelayFunction,\n    private retryIf: RetryFunction,\n  ) {}\n\n  /**\n   * Register a new observer for this operation.\n   *\n   * If the operation has previously emitted other events, they will be\n   * immediately triggered for the observer.\n   */\n  public subscribe(observer: Observer<TValue>) {\n    if (this.canceled) {\n      throw new Error(\n        `Subscribing to a retryable link that was canceled is not supported`,\n      );\n    }\n    this.observers.push(observer);\n\n    // If we've already begun, catch this observer up.\n    for (const value of this.values) {\n      observer.next!(value);\n    }\n\n    if (this.complete) {\n      observer.complete!();\n    } else if (this.error) {\n      observer.error!(this.error);\n    }\n  }\n\n  /**\n   * Remove a previously registered observer from this operation.\n   *\n   * If no observers remain, the operation will stop retrying, and unsubscribe\n   * from its downstream link.\n   */\n  public unsubscribe(observer: Observer<TValue>) {\n    const index = this.observers.indexOf(observer);\n    if (index < 0) {\n      throw new Error(\n        `RetryLink BUG! Attempting to unsubscribe unknown observer!`,\n      );\n    }\n    // Note that we are careful not to change the order of length of the array,\n    // as we are often mid-iteration when calling this method.\n    this.observers[index] = null;\n\n    // If this is the last observer, we're done.\n    if (this.observers.every(o => o === null)) {\n      this.cancel();\n    }\n  }\n\n  /**\n   * Start the initial request.\n   */\n  public start() {\n    if (this.currentSubscription) return; // Already started.\n\n    this.try();\n  }\n\n  /**\n   * Stop retrying for the operation, and cancel any in-progress requests.\n   */\n  public cancel() {\n    if (this.currentSubscription) {\n      this.currentSubscription.unsubscribe();\n    }\n    clearTimeout(this.timerId);\n    this.timerId = undefined;\n    this.currentSubscription = null;\n    this.canceled = true;\n  }\n\n  private try() {\n    this.currentSubscription = this.nextLink(this.operation).subscribe({\n      next: this.onNext,\n      error: this.onError,\n      complete: this.onComplete,\n    });\n  }\n\n  private onNext = (value: any) => {\n    this.values.push(value);\n    for (const observer of this.observers) {\n      if (!observer) continue;\n      observer.next!(value);\n    }\n  };\n\n  private onComplete = () => {\n    this.complete = true;\n    for (const observer of this.observers) {\n      if (!observer) continue;\n      observer.complete!();\n    }\n  };\n\n  private onError = async (error: any) => {\n    this.retryCount += 1;\n\n    // Should we retry?\n    const shouldRetry = await this.retryIf(\n      this.retryCount,\n      this.operation,\n      error,\n    );\n    if (shouldRetry) {\n      this.scheduleRetry(this.delayFor(this.retryCount, this.operation, error));\n      return;\n    }\n\n    this.error = error;\n    for (const observer of this.observers) {\n      if (!observer) continue;\n      observer.error!(error);\n    }\n  };\n\n  private scheduleRetry(delay: number) {\n    if (this.timerId) {\n      throw new Error(`RetryLink BUG! Encountered overlapping retries`);\n    }\n\n    this.timerId = (setTimeout(() => {\n      this.timerId = undefined;\n      this.try();\n    }, delay) as any) as number;\n  }\n}\n\nexport class RetryLink extends ApolloLink {\n  private delayFor: DelayFunction;\n  private retryIf: RetryFunction;\n\n  constructor(options?: RetryLink.Options) {\n    super();\n    const { attempts, delay } = options || ({} as RetryLink.Options);\n    this.delayFor =\n      typeof delay === 'function' ? delay : buildDelayFunction(delay);\n    this.retryIf =\n      typeof attempts === 'function' ? attempts : buildRetryFunction(attempts);\n  }\n\n  public request(\n    operation: Operation,\n    nextLink: NextLink,\n  ): Observable<FetchResult> {\n    const retryable = new RetryableOperation(\n      operation,\n      nextLink,\n      this.delayFor,\n      this.retryIf,\n    );\n    retryable.start();\n\n    return new Observable(observer => {\n      retryable.subscribe(observer);\n      return () => {\n        retryable.unsubscribe(observer);\n      };\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}