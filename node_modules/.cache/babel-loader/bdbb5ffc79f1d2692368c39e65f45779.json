{"ast":null,"code":"export function buildDelayFunction(delayOptions) {\n  var _a = delayOptions || {},\n      _b = _a.initial,\n      initial = _b === void 0 ? 300 : _b,\n      _c = _a.jitter,\n      jitter = _c === void 0 ? true : _c,\n      _d = _a.max,\n      max = _d === void 0 ? Infinity : _d;\n\n  var baseDelay = jitter ? initial : initial / 2;\n  return function delayFunction(count) {\n    var delay = Math.min(max, baseDelay * Math.pow(2, count));\n\n    if (jitter) {\n      delay = Math.random() * delay;\n    }\n\n    return delay;\n  };\n}","map":{"version":3,"mappings":"AA2CA,OAAM,SAAUA,kBAAV,CACJC,YADI,EAC+B;EAE7B,SAAmDA,YAAY,IAAI,EAAnE;EAAA,IAAEC,eAAF;EAAA,IAAEC,OAAO,mBAAG,GAAH,GAAMD,EAAf;EAAA,IAAiBE,cAAjB;EAAA,IAAiBC,MAAM,mBAAG,IAAH,GAAOD,EAA9B;EAAA,IAAgCE,WAAhC;EAAA,IAAgCC,GAAG,mBAAGC,QAAH,GAAWF,EAA9C;;EAKN,IAAMG,SAAS,GAAGJ,MAAM,GAAGF,OAAH,GAAaA,OAAO,GAAG,CAA/C;EAEA,OAAO,SAASO,aAAT,CAAuBC,KAAvB,EAAoC;IACzC,IAAIC,KAAK,GAAGC,IAAI,CAACC,GAAL,CAASP,GAAT,EAAcE,SAAS,GAAGI,YAAKF,KAAL,CAA1B,CAAZ;;IACA,IAAIN,MAAJ,EAAY;MAGVO,KAAK,GAAGC,IAAI,CAACE,MAAL,KAAgBH,KAAxB;IACD;;IAED,OAAOA,KAAP;EACD,CATD;AAUD","names":["buildDelayFunction","delayOptions","_b","initial","_c","jitter","_d","max","Infinity","baseDelay","delayFunction","count","delay","Math","min","random"],"sources":["/Users/evik/kl/project-2024/klasmart-assessment-frontend/node_modules/@apollo/src/link/retry/delayFunction.ts"],"sourcesContent":["import { Operation } from '../core';\n\n/**\n * Advanced mode: a function that implements the strategy for calculating delays\n * for particular responses.\n */\nexport interface DelayFunction {\n  (count: number, operation: Operation, error: any): number;\n}\n\nexport interface DelayFunctionOptions {\n  /**\n   * The number of milliseconds to wait before attempting the first retry.\n   *\n   * Delays will increase exponentially for each attempt.  E.g. if this is\n   * set to 100, subsequent retries will be delayed by 200, 400, 800, etc,\n   * until they reach maxDelay.\n   *\n   * Note that if jittering is enabled, this is the _average_ delay.\n   *\n   * Defaults to 300.\n   */\n  initial?: number;\n\n  /**\n   * The maximum number of milliseconds that the link should wait for any\n   * retry.\n   *\n   * Defaults to Infinity.\n   */\n  max?: number;\n\n  /**\n   * Whether delays between attempts should be randomized.\n   *\n   * This helps avoid thundering herd type situations by better distributing\n   * load during major outages.\n   *\n   * Defaults to true.\n   */\n  jitter?: boolean;\n}\n\nexport function buildDelayFunction(\n  delayOptions?: DelayFunctionOptions,\n): DelayFunction {\n  const { initial = 300, jitter = true, max = Infinity } = delayOptions || {};\n  // If we're jittering, baseDelay is half of the maximum delay for that\n  // attempt (and is, on average, the delay we will encounter).\n  // If we're not jittering, adjust baseDelay so that the first attempt\n  // lines up with initialDelay, for everyone's sanity.\n  const baseDelay = jitter ? initial : initial / 2;\n\n  return function delayFunction(count: number) {\n    let delay = Math.min(max, baseDelay * 2 ** count);\n    if (jitter) {\n      // We opt for a full jitter approach for a mostly uniform distribution,\n      // but bound it within initialDelay and delay for everyone's sanity.\n      delay = Math.random() * delay;\n    }\n\n    return delay;\n  };\n}\n"]},"metadata":{},"sourceType":"module"}